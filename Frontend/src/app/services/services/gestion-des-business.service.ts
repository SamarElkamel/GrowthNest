/* tslint:disable */
/* eslint-disable */
/* Code generated by ng-openapi-gen DO NOT EDIT. */

import { HttpClient, HttpContext, HttpHeaders, HttpResponse } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable, Subject } from 'rxjs';
import { catchError, filter, map, tap } from 'rxjs/operators';

import { BaseService } from '../base-service';
import { ApiConfiguration } from '../api-configuration';
import { StrictHttpResponse } from '../strict-http-response';

import { addBusiness } from '../fn/gestion-des-business/add-business';
import { AddBusiness$Params } from '../fn/gestion-des-business/add-business';
import { Business } from '../models/business';
import { Task } from '../models/business';

import { deleteBusiness } from '../fn/gestion-des-business/delete-business';
import { DeleteBusiness$Params } from '../fn/gestion-des-business/delete-business';
import { getAllBusiness } from '../fn/gestion-des-business/get-all-business';
import { GetAllBusiness$Params } from '../fn/gestion-des-business/get-all-business';
import { getBusinessById } from '../fn/gestion-des-business/get-business-by-id';
import { GetBusinessById$Params } from '../fn/gestion-des-business/get-business-by-id';
import { updateBusiness } from '../fn/gestion-des-business/update-business';
import { UpdateBusiness$Params } from '../fn/gestion-des-business/update-business';
import { Router } from '@angular/router';
import { RequestBuilder } from '../request-builder';

@Injectable({ providedIn: 'root' })
export class GestionDesBusinessService extends BaseService {
  private refreshList$ = new Subject<void>();
  private currentBusiness = new BehaviorSubject<Business | null>(null);

  constructor(config: ApiConfiguration, http: HttpClient, private router: Router) {
    super(config, http);
  }

  /** Path part for operation `uploadLogo()` */
  static readonly UploadLogoPath = '/business/upload-logo';

  /**
   * Uploader un logo
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `uploadLogo()` instead.
   *
   * This method sends `image/*` and handles request body of type `File`.
   */
  uploadLogo$Response(params: { body: File }, context?: HttpContext): Observable<StrictHttpResponse<string>> {
    const rb = new RequestBuilder(this.rootUrl, GestionDesBusinessService.UploadLogoPath, 'post');
    if (params) {
      rb.body(params.body, params.body.type || 'image/jpeg');
    }

    return this.http.request(
      rb.build({
        responseType: 'text',
        accept: 'text/plain',
        context,
      })
    ).pipe(
      filter((r: any) => r instanceof HttpResponse),
      map((r: HttpResponse<any>) => r as StrictHttpResponse<string>)
    );
  }

  /**
   * Uploader un logo
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `uploadLogo$Response()` instead.
   *
   * This method sends `image/*` and handles request body of type `File`.
   */
  uploadLogo(params: { body: File }, context?: HttpContext): Observable<string> {
    return this.uploadLogo$Response(params, context).pipe(
      map((r: StrictHttpResponse<string>): string => r.body)
    );
  }


/** Path part for operation `addBusiness()` */
static readonly AddBusinessPath = '/business/addBusiness';

/**
 * Ajouter un business avec logo et PDF optionnels
 */
addBusiness$Response(business: any, logo?: File, pdf?: File, context?: HttpContext): Observable<StrictHttpResponse<Business>> {
  const formData = new FormData();
  // Send business as plain JSON string, matching Swagger
  const businessJson = JSON.stringify(business);
  formData.append('business', businessJson);
  if (logo) {
    formData.append('logo', logo, logo.name);
  }
  if (pdf) {
    formData.append('pdf', pdf, pdf.name);
  }

  // Log FormData contents
  console.log('FormData parts:');
  console.log('business:', businessJson);
  console.log('logo:', logo ? `${logo.name} (type: ${logo.type})` : 'null');
  console.log('pdf:', pdf ? `${pdf.name} (type: ${pdf.type})` : 'null');

  const headers = new HttpHeaders({
    Accept: '*/*'
  });

  return this.http.post<Business>(
    `${this.rootUrl}${GestionDesBusinessService.AddBusinessPath}`,
    formData,
    { headers, context, observe: 'response' }
  ).pipe(
    filter((r: any) => r instanceof HttpResponse),
    map((r: HttpResponse<Business>) => {
      console.log('Response:', r);
      return r as StrictHttpResponse<Business>;
    })
  );
}

/**
 * Ajouter un business avec logo et PDF optionnels
 */
addBusiness(business: any, logo?: File, pdf?: File, context?: HttpContext): Observable<Business> {
  return this.addBusiness$Response(business, logo, pdf, context).pipe(
    map((r: StrictHttpResponse<Business>) => r.body),
    tap({
      next: (newBusiness) => {
        this.currentBusiness.next(newBusiness);
      },
      error: (err) => console.error('Erreur création business:', err),
    })
  );}


  /** Path part for operation `updateBusiness()` */
  static readonly UpdateBusinessPath = '/business/updateBusiness';

  /**
   * Modifier un business
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `updateBusiness()` instead.
   *
   * This method sends `application/json` and handles request body of type `application/json`.
   */
  updateBusiness$Response(params: UpdateBusiness$Params, context?: HttpContext): Observable<StrictHttpResponse<Business>> {
    return updateBusiness(this.http, this.rootUrl, params, context);
  }

  /**
   * Modifier un business
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `updateBusiness$Response()` instead.
   *
   * This method sends `application/json` and handles request body of type `application/json`.
   */
  updateBusiness(params: UpdateBusiness$Params, context?: HttpContext): Observable<Business> {
    return this.updateBusiness$Response(params, context).pipe(
      map((r: StrictHttpResponse<Business>): Business => r.body)
    );
  }

  /** Path part for operation `getBusinessById()` */
  static readonly GetBusinessByIdPath = '/business/getBusinessById/{idB}';

  /**
   * Afficher un business selon l'id
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `getBusinessById()` instead.
   *
   * This method doesn't expect any request body.
   */
  getBusinessById$Response(params: GetBusinessById$Params, context?: HttpContext): Observable<StrictHttpResponse<Business>> {
    return getBusinessById(this.http, this.rootUrl, params, context);
  }

  /**
   * Afficher un business selon l'id
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `getBusinessById$Response()` instead.
   *
   * This method doesn't expect any request body.
   */
  getBusinessById(params: GetBusinessById$Params, context?: HttpContext): Observable<Business> {
    return this.getBusinessById$Response(params, context).pipe(
      map((r: StrictHttpResponse<Business>): Business => r.body)
    );
  }

  /** Path part for operation `getAllBusiness()` */
  static readonly GetAllBusinessPath = '/business/getAllBusiness';

  /**
   * Afficher tous les business
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `getAllBusiness()` instead.
   *
   * This method doesn't expect any request body.
   */
  getAllBusiness$Response(params?: GetAllBusiness$Params, context?: HttpContext): Observable<StrictHttpResponse<Array<Business>>> {
    return getAllBusiness(this.http, this.rootUrl, params, context);
  }

  /**
   * Afficher tous les business
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `getAllBusiness$Response()` instead.
   *
   * This method doesn't expect any request body.
   */
  getAllBusiness(params?: GetAllBusiness$Params, context?: HttpContext): Observable<Array<Business>> {
    return this.getAllBusiness$Response(params, context).pipe(
      map((r: StrictHttpResponse<Array<Business>>): Array<Business> => r.body)
    );
  }

  /** Path part for operation `deleteBusiness()` */
  static readonly DeleteBusinessPath = '/business/deleteBusiness/{idB}';

  /**
   * Supprimer un business
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `deleteBusiness()` instead.
   *
   * This method doesn't expect any request body.
   */
  deleteBusiness$Response(params: DeleteBusiness$Params, context?: HttpContext): Observable<StrictHttpResponse<void>> {
    return deleteBusiness(this.http, this.rootUrl, params, context);
  }

  /**
   * Supprimer un business
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `deleteBusiness$Response()` instead.
   *
   * This method doesn't expect any request body.
   */
  deleteBusiness(params: DeleteBusiness$Params, context?: HttpContext): Observable<void> {
    return this.deleteBusiness$Response(params, context).pipe(
      map((r: StrictHttpResponse<void>): void => r.body)
    );
  }

  /** Path part for operation `rateBusiness()` */
  static readonly RateBusinessPath = '/business/{businessId}/rate';

  /**
   * Rate a business
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `rateBusiness()` instead.
   *
   * This method sends `application/json` and handles request body of type `application/json`.
   */
  rateBusiness$Response(params: { businessId: number; ratingValue: number }, context?: HttpContext): Observable<StrictHttpResponse<void>> {
    if (params.ratingValue < 1 || params.ratingValue > 5) {
      console.error(`Invalid rating value: ${params.ratingValue}. Must be between 1 and 5.`);
      throw new Error('Rating value must be between 1 and 5');
    }
    console.log(`Submitting rating: businessId=${params.businessId}, ratingValue=${params.ratingValue}`);
    const rb = new RequestBuilder(this.rootUrl, GestionDesBusinessService.RateBusinessPath, 'post');
    if (params) {
      rb.path('businessId', params.businessId, {});
      rb.body(params.ratingValue, 'application/json');
    }

    return this.http.request(
      rb.build({
        responseType: 'json',
        accept: 'application/json',
        context,
      })
    ).pipe(
      filter((r: any) => r instanceof HttpResponse),
      map((r: HttpResponse<any>) => r as StrictHttpResponse<void>),
      tap({
        next: () => console.log(`Rating submitted successfully: businessId=${params.businessId}`),
        error: (err) => console.error(`Error submitting rating for businessId=${params.businessId}: ${err.message}`)
      })
    );
  }

  /**
   * Rate a business
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `rateBusiness$Response()` instead.
   *
   * This method sends `application/json` and handles request body of type `application/json`.
   */
  rateBusiness(params: { businessId: number; ratingValue: number }, context?: HttpContext): Observable<void> {
    return this.rateBusiness$Response(params, context).pipe(
      map((r: StrictHttpResponse<void>): void => r.body)
    );
  }

  /** Path part for operation `getUserRating()` */
  static readonly GetUserRatingPath = '/business/{businessId}/user-rating';

  /**
   * Get user rating for a business
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `getUserRating()` instead.
   *
   * This method doesn't expect any request body.
   */
  getUserRating$Response(params: { businessId: number }, context?: HttpContext): Observable<StrictHttpResponse<number | null>> {
    console.log(`Fetching user rating for businessId=${params.businessId}`);
    const rb = new RequestBuilder(this.rootUrl, GestionDesBusinessService.GetUserRatingPath, 'get');
    if (params) {
      rb.path('businessId', params.businessId, {});
    }
    return this.http.request(
      rb.build({
        responseType: 'json',
        accept: 'application/json',
        context,
      })
    ).pipe(
      filter((r: any) => r instanceof HttpResponse),
      map((r: HttpResponse<any>) => r as StrictHttpResponse<number | null>),
      tap({
        next: (r) => console.log(`User rating fetched: businessId=${params.businessId}, value=${r.body}`),
        error: (err) => console.error(`Error fetching user rating for businessId=${params.businessId}: ${err.message}`)
      })
    );
  }

  /**
   * Get user rating for a business
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `getUserRating$Response()` instead.
   *
   * This method doesn't expect any request body.
   */
  getUserRating(params: { businessId: number }, context?: HttpContext): Observable<number | null> {
    return this.getUserRating$Response(params, context).pipe(
      map((r: StrictHttpResponse<number | null>) => r.body)
    );
  }

  /**
   * Get the current business
   */
  getCurrentBusiness(): Observable<Business | null> {
    return this.currentBusiness.asObservable();
  }

  /**
   * Navigate to business details
   */
  navigateToBusinessDetails(idBusiness: number): void {
    this.router.navigate([`/admin/my-business/${idBusiness}`]);
  }

  /**
   * Trigger a list refresh
   */
  triggerRefresh(): void {
    this.refreshList$.next();
  }

  /**
   * Observable for refresh requests
   */
  getRefreshObservable(): Observable<void> {
    return this.refreshList$.asObservable();
  }

  /** Path part for operation `getQRCodeForBusiness()` */
  static readonly GetQRCodeForBusinessPath = '/business/{id}/qrcode';

  /**
   * Récupérer le QR Code pour un business
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `getQRCodeForBusiness()` instead.
   *
   * This method doesn't expect any request body.
   */
  getQRCodeForBusiness$Response(params: { id: number; width?: number; height?: number }, context?: HttpContext): Observable<StrictHttpResponse<Blob>> {
    console.log(`Fetching QR code for businessId=${params.id}`);
    const rb = new RequestBuilder(this.rootUrl, GestionDesBusinessService.GetQRCodeForBusinessPath, 'get');
    if (params) {
      rb.path('id', params.id, {});
      rb.query('width', params.width || 200, {});
      rb.query('height', params.height || 200, {});
    }

    return this.http.request(
      rb.build({
        responseType: 'blob',
        accept: 'image/png',
        context,
      })
    ).pipe(
      filter((r: any) => r instanceof HttpResponse),
      map((r: HttpResponse<any>) => r as StrictHttpResponse<Blob>),
      tap({
        next: () => console.log(`QR code fetched for businessId=${params.id}`),
        error: (err) => console.error(`Error fetching QR code for businessId=${params.id}: ${err.message}`)
      })
    );
  }

  /**
   * Récupérer le QR Code pour un business
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `getQRCodeForBusiness$Response()` instead.
   *
   * This method doesn't expect any request body.
   */
  getQRCodeForBusiness(params: { id: number; width?: number; height?: number }, context?: HttpContext): Observable<Blob> {
    return this.getQRCodeForBusiness$Response(params, context).pipe(
      map((r: StrictHttpResponse<Blob>): Blob => r.body)
    );
  }
  /** Path part for operation `downloadBusinessPdf()` */
  static readonly DownloadBusinessPdfPath = '/business/{id}/pdf';

  /**
   * Télécharger le PDF d'un business
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `downloadBusinessPdf()` instead.
   *
   * This method doesn't expect any request body.
   */
  downloadBusinessPdf$Response(params: { id: number }, context?: HttpContext): Observable<StrictHttpResponse<Blob>> {
    console.log(`Fetching PDF for businessId=${params.id}`);
    const rb = new RequestBuilder(this.rootUrl, GestionDesBusinessService.DownloadBusinessPdfPath, 'get');
    if (params) {
      rb.path('id', params.id, {});
    }

    return this.http.request(
      rb.build({
        responseType: 'blob',
        accept: 'application/pdf',
        context,
      })
    ).pipe(
      filter((r: any) => r instanceof HttpResponse),
      map((r: HttpResponse<any>) => r as StrictHttpResponse<Blob>),
      tap({
        next: () => console.log(`PDF fetched for businessId=${params.id}`),
        error: (err) => console.error(`Error fetching PDF for businessId=${params.id}: ${err.message}`)
      })
    );
  }

  /**
   * Télécharger le PDF d'un business
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `downloadBusinessPdf$Response()` instead.
   *
   * This method doesn't expect any request body.
   */
  downloadBusinessPdf(params: { id: number }, context?: HttpContext): Observable<Blob> {
    return this.downloadBusinessPdf$Response(params, context).pipe(
      map((r: StrictHttpResponse<Blob>): Blob => r.body)
    );
  }
   /** Path part for operation `approveBusiness()` */
   static readonly ApproveBusinessPath = '/business/approve/{id}';

   /**
    * Approuver un business
    *
    * This method provides access to the full `HttpResponse`, allowing access to response headers.
    * To access only the response body, use `approveBusiness()` instead.
    *
    * This method doesn't expect any request body.
    */
   approveBusiness$Response(params: { id: number }, context?: HttpContext): Observable<StrictHttpResponse<Business>> {
     const rb = new RequestBuilder(this.rootUrl, GestionDesBusinessService.ApproveBusinessPath, 'post');
     if (params) {
       rb.path('id', params.id, {});
     }
     return this.http.request(
       rb.build({ responseType: 'json', accept: 'application/json', context })
     ).pipe(
       filter((r: any) => r instanceof HttpResponse),
       map((r: HttpResponse<any>) => r as StrictHttpResponse<Business>),
       tap({
         next: () => console.log(`Business approved: ID=${params.id}`),
         error: (err) => console.error(`Error approving business ID=${params.id}: ${err.message}`)
       })
     );
   }
 
   /**
    * Approuver un business
    *
    * This method provides access only to the response body.
    * To access the full response (for headers, for example), `approveBusiness$Response()` instead.
    *
    * This method doesn't expect any request body.
    */
   approveBusiness(params: { id: number }, context?: HttpContext): Observable<Business> {
     return this.approveBusiness$Response(params, context).pipe(
       map((r: StrictHttpResponse<Business>) => r.body)
     );
   }
 
   /** Path part for operation `rejectBusiness()` */
   static readonly RejectBusinessPath = '/business/reject/{id}';
 
   /**
    * Rejeter un business
    *
    * This method provides access to the full `HttpResponse`, allowing access to response headers.
    * To access only the response body, use `rejectBusiness()` instead.
    *
    * This method doesn't expect any request body.
    */
   rejectBusiness$Response(params: { id: number }, context?: HttpContext): Observable<StrictHttpResponse<Business>> {
     const rb = new RequestBuilder(this.rootUrl, GestionDesBusinessService.RejectBusinessPath, 'post');
     if (params) {
       rb.path('id', params.id, {});
     }
     return this.http.request(
       rb.build({ responseType: 'json', accept: 'application/json', context })
     ).pipe(
       filter((r: any) => r instanceof HttpResponse),
       map((r: HttpResponse<any>) => r as StrictHttpResponse<Business>),
       tap({
         next: () => console.log(`Business rejected: ID=${params.id}`),
         error: (err) => console.error(`Error rejecting business ID=${params.id}: ${err.message}`)
       })
     );
   }
 
   /**
    * Rejeter un business
    *
    * This method provides access only to the response body.
    * To access the full response (for headers, for example), `rejectBusiness$Response()` instead.
    *
    * This method doesn't expect any request body.
    */
   rejectBusiness(params: { id: number }, context?: HttpContext): Observable<Business> {
     return this.rejectBusiness$Response(params, context).pipe(
       map((r: StrictHttpResponse<Business>) => r.body)
     );
   }
   // gestion-des-business.service.ts
/** Path part for operation `updateBusinessWithFiles()` */
static readonly UpdateBusinessWithFilesPath = '/business/updateBusinessWithFiles';

updateBusinessWithFiles(formData: FormData): Observable<Business> {
  console.log('Sending updateBusinessWithFiles request:');
  formData.forEach((value, key) => {
    if (key === 'business') {
      console.log('business:', value);
    } else {
      console.log(`${key}:`, (value as File).name || 'null');
    }
  });
  return this.http.put<Business>(
    `${this.rootUrl}${GestionDesBusinessService.UpdateBusinessWithFilesPath}`,
    formData
  ).pipe(
    tap((response) => console.log('Update response:', response)),
    catchError((err) => {
      console.error('Update error:', err);
      throw err;
    })
  );
}

getBaseUrl(): string {
  try {
    const url = new URL(this.rootUrl);
    return `${url.protocol}//${url.host}`;
  } catch (e) {
    console.error('Error parsing rootUrl:', e);
    return 'http://localhost:8080'; // Fallback
  }
}
static readonly getTopThreeBusinessesPath = '/business/getTopThreeBusinesses';

getTopThreeBusinesses(): Observable<Business[]> {
  return this.http.get<Business[]>(`${this.rootUrl}${GestionDesBusinessService.getTopThreeBusinessesPath}`);
}
/** Path part for operation `addTask()` */
static readonly AddTaskPath = '/business/{businessId}/tasks';

/**
 * Ajouter une tâche à un business
 */
addTask$Response(params: { businessId: number; body: Task }, context?: HttpContext): Observable<StrictHttpResponse<Task>> {
  console.log(`Adding task for businessId=${params.businessId}`);
  const rb = new RequestBuilder(this.rootUrl, GestionDesBusinessService.AddTaskPath, 'post');
  if (params) {
    rb.path('businessId', params.businessId, {});
    rb.body(params.body, 'application/json');
  }

  return this.http.request(
    rb.build({
      responseType: 'json',
      accept: 'application/json',
      context,
    })
  ).pipe(
    filter((r: any) => r instanceof HttpResponse),
    map((r: HttpResponse<any>) => r as StrictHttpResponse<Task>),
    tap({
      next: (r) => console.log(`Task added successfully: businessId=${params.businessId}, taskId=${r.body.id}`),
      error: (err) => console.error(`Error adding task for businessId=${params.businessId}: ${err.message}`)
    })
  );
}

/**
 * Ajouter une tâche à un business
 */
addTask(params: { businessId: number; body: Task }, context?: HttpContext): Observable<Task> {
  return this.addTask$Response(params, context).pipe(
    map((r: StrictHttpResponse<Task>): Task => r.body)
  );
}

/** Path part for operation `getTasksByBusiness()` */
static readonly GetTasksByBusinessPath = '/business/{businessId}/tasks';

/**
 * Récupérer les tâches d'un business
 */
getTasksByBusiness$Response(params: { businessId: number }, context?: HttpContext): Observable<StrictHttpResponse<Array<Task>>> {
  console.log(`Fetching tasks for businessId=${params.businessId}`);
  const rb = new RequestBuilder(this.rootUrl, GestionDesBusinessService.GetTasksByBusinessPath, 'get');
  if (params) {
    rb.path('businessId', params.businessId, {});
  }

  return this.http.request(
    rb.build({
      responseType: 'json',
      accept: 'application/json',
      context,
    })
  ).pipe(
    filter((r: any) => r instanceof HttpResponse),
    map((r: HttpResponse<any>) => r as StrictHttpResponse<Array<Task>>),
    tap({
      next: () => console.log(`Tasks fetched for businessId=${params.businessId}`),
      error: (err) => console.error(`Error fetching tasks for businessId=${params.businessId}: ${err.message}`)
    })
  );
}

/**
 * Récupérer les tâches d'un business
 */
getTasksByBusiness(params: { businessId: number }, context?: HttpContext): Observable<Array<Task>> {
  return this.getTasksByBusiness$Response(params, context).pipe(
    map((r: StrictHttpResponse<Array<Task>>): Array<Task> => r.body)
  );
}

/** Path part for operation `updateTask()` */
static readonly UpdateTaskPath = '/business/tasks/{taskId}';

/**
 * Mettre à jour une tâche
 */
updateTask$Response(params: { taskId: number; body: Task }, context?: HttpContext): Observable<StrictHttpResponse<Task>> {
  console.log(`Updating taskId=${params.taskId}`);
  const rb = new RequestBuilder(this.rootUrl, GestionDesBusinessService.UpdateTaskPath, 'put');
  if (params) {
    rb.path('taskId', params.taskId, {});
    rb.body(params.body, 'application/json');
  }

  return this.http.request(
    rb.build({
      responseType: 'json',
      accept: 'application/json',
      context,
    })
  ).pipe(
    filter((r: any) => r instanceof HttpResponse),
    map((r: HttpResponse<any>) => r as StrictHttpResponse<Task>),
    tap({
      next: (r) => console.log(`Task updated successfully: taskId=${params.taskId}`),
      error: (err) => console.error(`Error updating taskId=${params.taskId}: ${err.message}`)
    })
  );
}

/**
 * Mettre à jour une tâche
 */
updateTask(params: { taskId: number; body: Task }, context?: HttpContext): Observable<Task> {
  return this.updateTask$Response(params, context).pipe(
    map((r: StrictHttpResponse<Task>): Task => r.body)
  );
}

/** Path part for operation `deleteTask()` */
static readonly DeleteTaskPath = '/business/tasks/{taskId}';

/**
 * Supprimer une tâche
 */
deleteTask$Response(params: { taskId: number }, context?: HttpContext): Observable<StrictHttpResponse<void>> {
  console.log(`Deleting taskId=${params.taskId}`);
  const rb = new RequestBuilder(this.rootUrl, GestionDesBusinessService.DeleteTaskPath, 'delete');
  if (params) {
    rb.path('taskId', params.taskId, {});
  }

  return this.http.request(
    rb.build({
      responseType: 'json',
      accept: 'application/json',
      context,
    })
  ).pipe(
    filter((r: any) => r instanceof HttpResponse),
    map((r: HttpResponse<any>) => r as StrictHttpResponse<void>),
    tap({
      next: () => console.log(`Task deleted successfully: taskId=${params.taskId}`),
      error: (err) => console.error(`Error deleting taskId=${params.taskId}: ${err.message}`)
    })
  );
}

/**
 * Supprimer une tâche
 */
deleteTask(params: { taskId: number }, context?: HttpContext): Observable<void> {
  return this.deleteTask$Response(params, context).pipe(
    map((r: StrictHttpResponse<void>): void => r.body)
  );
}

/** Path part for operation `reorderTasks()` */
static readonly ReorderTasksPath = '/business/{businessId}/tasks/reorder';

/**
 * Réorganiser les tâches
 */
reorderTasks$Response(params: { businessId: number; body: Task[] }, context?: HttpContext): Observable<StrictHttpResponse<void>> {
  console.log(`Reordering tasks for businessId=${params.businessId}`);
  const rb = new RequestBuilder(this.rootUrl, GestionDesBusinessService.ReorderTasksPath, 'post');
  if (params) {
    rb.path('businessId', params.businessId, {});
    rb.body(params.body, 'application/json');
  }

  return this.http.request(
    rb.build({
      responseType: 'json',
      accept: 'application/json',
      context,
    })
  ).pipe(
    filter((r: any) => r instanceof HttpResponse),
    map((r: HttpResponse<any>) => r as StrictHttpResponse<void>),
    tap({
      next: () => console.log(`Tasks reordered successfully for businessId=${params.businessId}`),
      error: (err) => console.error(`Error reordering tasks for businessId=${params.businessId}: ${err.message}`)
    })
  );
}

/**
 * Réorganiser les tâches
 */
reorderTasks(params: { businessId: number; body: Task[] }, context?: HttpContext): Observable<void> {
  return this.reorderTasks$Response(params, context).pipe(
    map((r: StrictHttpResponse<void>): void => r.body)
  );
}
static readonly GetMyBusinessesPath = '/business/my-businesses';

/**
 * Récupérer les businesses de l'utilisateur connecté
 */
getMyBusinesses(context?: HttpContext): Observable<Business[]> {
  console.log('Fetching businesses for the current user');
  return this.http.get<Business[]>(
    `${this.rootUrl}${GestionDesBusinessService.GetMyBusinessesPath}`,
    { context }
  ).pipe(
    tap({
      next: (businesses) => console.log(`Fetched ${businesses.length} businesses for current user`, businesses),
      error: (err) => console.error(`Error fetching businesses: ${err.message}`)
    })
  );
}

}